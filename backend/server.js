const express = require('express');
const cors = require('cors');
const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');
const util = require('util');
const { registerProcessRoutes } = require('./routes');
const processManager = require('./processManager');
require('dotenv').config({ path: path.resolve(__dirname, '../.env') });

const execPromise = util.promisify(exec);

const app = express();
const PORT = 9999;

// é¡¹ç›®æ ¹ç›®å½•ï¼ˆbackendçš„ä¸Šä¸Šçº§ç›®å½•ï¼‰
const PROJECT_ROOT = process.env.PROJECT_ROOT || path.resolve(__dirname, '../..');
const PROJECTS_CONFIG = path.join(PROJECT_ROOT, '.claude/projects.json');
const ENV_FILE = path.resolve(__dirname, '../.env');

app.use(cors());
app.use(express.json());

// æä¾›å‰ç«¯é™æ€æ–‡ä»¶
app.use(express.static(path.join(__dirname, '../frontend/dist')));

// ========== API è·¯ç”± ==========

// é…ç½®ç®¡ç†API
// è·å–é…ç½®
app.get('/api/config', (req, res) => {
  try {
    const config = {
      ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY || '',
      ANTHROPIC_BASE_URL: process.env.ANTHROPIC_BASE_URL || 'https://api.husanai.com',
      PROJECT_ROOT: process.env.PROJECT_ROOT || ''
    };
    res.json(config);
  } catch (error) {
    res.status(500).json({ error: 'è¯»å–é…ç½®å¤±è´¥', message: error.message });
  }
});

// ä¿å­˜é…ç½®
app.post('/api/config', (req, res) => {
  try {
    const { ANTHROPIC_API_KEY, ANTHROPIC_BASE_URL, PROJECT_ROOT } = req.body;

    // è¯»å–ç°æœ‰çš„ .env æ–‡ä»¶æˆ–åˆ›å»ºæ–°çš„
    let envContent = '';
    if (fs.existsSync(ENV_FILE)) {
      envContent = fs.readFileSync(ENV_FILE, 'utf8');
    }

    // è§£æç°æœ‰é…ç½®
    const envLines = envContent.split('\n');
    const envMap = new Map();
    const comments = [];

    envLines.forEach(line => {
      if (line.trim().startsWith('#') || line.trim() === '') {
        comments.push(line);
      } else if (line.includes('=')) {
        const [key, ...valueParts] = line.split('=');
        envMap.set(key.trim(), valueParts.join('=').trim());
      }
    });

    // æ›´æ–°é…ç½®
    if (ANTHROPIC_API_KEY !== undefined) {
      envMap.set('ANTHROPIC_API_KEY', ANTHROPIC_API_KEY);
    }
    if (ANTHROPIC_BASE_URL !== undefined) {
      envMap.set('ANTHROPIC_BASE_URL', ANTHROPIC_BASE_URL);
    }
    if (PROJECT_ROOT !== undefined) {
      envMap.set('PROJECT_ROOT', PROJECT_ROOT);
    }

    // ç”Ÿæˆæ–°çš„ .env å†…å®¹
    const newEnvContent = [
      '# Environment Configuration',
      '# Generated by Claude Code Project Manager',
      '',
      '# Claude API Configuration',
      `ANTHROPIC_API_KEY=${envMap.get('ANTHROPIC_API_KEY') || ''}`,
      `ANTHROPIC_BASE_URL=${envMap.get('ANTHROPIC_BASE_URL') || 'https://api.husanai.com'}`,
      '',
      '# Server Configuration',
      `PORT=${envMap.get('PORT') || '9999'}`,
      '',
      '# Project Root',
      `PROJECT_ROOT=${envMap.get('PROJECT_ROOT') || ''}`,
      ''
    ].join('\n');

    fs.writeFileSync(ENV_FILE, newEnvContent, 'utf8');

    // æ›´æ–°ç¯å¢ƒå˜é‡
    process.env.ANTHROPIC_API_KEY = envMap.get('ANTHROPIC_API_KEY') || '';
    process.env.ANTHROPIC_BASE_URL = envMap.get('ANTHROPIC_BASE_URL') || 'https://api.husanai.com';
    process.env.PROJECT_ROOT = envMap.get('PROJECT_ROOT') || '';

    res.json({ success: true, message: 'é…ç½®ä¿å­˜æˆåŠŸ' });
  } catch (error) {
    res.status(500).json({ error: 'ä¿å­˜é…ç½®å¤±è´¥', message: error.message });
  }
});

// 1. è·å–æ‰€æœ‰é¡¹ç›®
app.get('/api/projects', (req, res) => {
  try {
    const config = JSON.parse(fs.readFileSync(PROJECTS_CONFIG, 'utf8'));
    res.json(config);
  } catch (error) {
    res.status(500).json({ error: 'è¯»å–é¡¹ç›®é…ç½®å¤±è´¥', message: error.message });
  }
});

// 2. è·å–å•ä¸ªé¡¹ç›®çŠ¶æ€
app.get('/api/projects/:name/status', async (req, res) => {
  try {
    const { name } = req.params;
    const config = JSON.parse(fs.readFileSync(PROJECTS_CONFIG, 'utf8'));

    // æŸ¥æ‰¾é¡¹ç›®ï¼ˆå¯èƒ½åœ¨ projects æˆ– external ä¸­ï¼‰
    let project = config.projects[name];
    if (!project && config.external && config.external[name]) {
      project = config.external[name];
    }

    if (!project) {
      return res.status(404).json({ error: 'é¡¹ç›®ä¸å­˜åœ¨' });
    }

    // å¦‚æœæ˜¯ç»å¯¹è·¯å¾„ç›´æ¥ä½¿ç”¨ï¼Œå¦åˆ™ç›¸å¯¹äºé¡¹ç›®æ ¹ç›®å½•
    const projectPath = path.isAbsolute(project.path)
      ? project.path
      : path.join(PROJECT_ROOT, project.path);
    const status = await checkProjectStatus(projectPath, project);

    res.json({ name, ...status });
  } catch (error) {
    res.status(500).json({ error: 'æ£€æŸ¥é¡¹ç›®çŠ¶æ€å¤±è´¥', message: error.message });
  }
});

// 3. æ‰¹é‡è·å–é¡¹ç›®çŠ¶æ€
app.post('/api/projects/status/batch', async (req, res) => {
  try {
    const { projectNames } = req.body;
    const config = JSON.parse(fs.readFileSync(PROJECTS_CONFIG, 'utf8'));

    const statusPromises = projectNames.map(async (name) => {
      // æŸ¥æ‰¾é¡¹ç›®ï¼ˆå¯èƒ½åœ¨ projects æˆ– external ä¸­ï¼‰
      let project = config.projects[name];
      if (!project && config.external && config.external[name]) {
        project = config.external[name];
      }

      if (!project) return { name, error: 'é¡¹ç›®ä¸å­˜åœ¨' };

      // å¦‚æœæ˜¯ç»å¯¹è·¯å¾„ç›´æ¥ä½¿ç”¨ï¼Œå¦åˆ™ç›¸å¯¹äºé¡¹ç›®æ ¹ç›®å½•
      const projectPath = path.isAbsolute(project.path)
        ? project.path
        : path.join(PROJECT_ROOT, project.path);
      const status = await checkProjectStatus(projectPath, project);
      return { name, ...status };
    });

    const results = await Promise.all(statusPromises);
    res.json(results);
  } catch (error) {
    res.status(500).json({ error: 'æ‰¹é‡æ£€æŸ¥å¤±è´¥', message: error.message });
  }
});

// 4. æ›´æ–°é¡¹ç›®é…ç½®
app.put('/api/projects', (req, res) => {
  try {
    const newConfig = req.body;
    fs.writeFileSync(PROJECTS_CONFIG, JSON.stringify(newConfig, null, 2), 'utf8');
    res.json({ success: true, message: 'é…ç½®æ›´æ–°æˆåŠŸ' });
  } catch (error) {
    res.status(500).json({ error: 'æ›´æ–°é…ç½®å¤±è´¥', message: error.message });
  }
});

// 5. æ‰§è¡Œé¡¹ç›®æ“ä½œ
app.post('/api/projects/:name/action', async (req, res) => {
  try {
    const { name } = req.params;
    const { action, params } = req.body;

    const config = JSON.parse(fs.readFileSync(PROJECTS_CONFIG, 'utf8'));

    // æŸ¥æ‰¾é¡¹ç›®ï¼ˆå¯èƒ½åœ¨ projects æˆ– external ä¸­ï¼‰
    let project = config.projects[name];
    if (!project && config.external && config.external[name]) {
      project = config.external[name];
    }

    if (!project) {
      return res.status(404).json({ error: 'é¡¹ç›®ä¸å­˜åœ¨' });
    }

    // å¦‚æœæ˜¯ç»å¯¹è·¯å¾„ç›´æ¥ä½¿ç”¨ï¼Œå¦åˆ™ç›¸å¯¹äºé¡¹ç›®æ ¹ç›®å½•
    const projectPath = path.isAbsolute(project.path)
      ? project.path
      : path.join(PROJECT_ROOT, project.path);
    const result = await executeAction(action, projectPath, project, params);

    res.json(result);
  } catch (error) {
    res.status(500).json({ error: 'æ‰§è¡Œæ“ä½œå¤±è´¥', message: error.message });
  }
});

// ========== è¾…åŠ©å‡½æ•° ==========

// æ£€æŸ¥é¡¹ç›®çŠ¶æ€
async function checkProjectStatus(projectPath, project) {
  const status = {
    exists: fs.existsSync(projectPath),
    hasGit: false,
    gitBranch: null,
    uncommittedFiles: 0,
    hasDependencies: false,
    dependenciesInstalled: false,
    port: project.port || null
  };

  if (!status.exists) return status;

  // æ£€æŸ¥ Git çŠ¶æ€
  const gitPath = path.join(projectPath, '.git');
  status.hasGit = fs.existsSync(gitPath);

  if (status.hasGit) {
    try {
      const { stdout: branch } = await execPromise('git branch --show-current', { cwd: projectPath });
      status.gitBranch = branch.trim();

      const { stdout: statusOutput } = await execPromise('git status --porcelain', { cwd: projectPath });
      status.uncommittedFiles = statusOutput.trim().split('\n').filter(l => l).length;
    } catch (error) {
      // Git å‘½ä»¤å¤±è´¥ï¼Œå¿½ç•¥
    }
  }

  // æ£€æŸ¥ä¾èµ–çŠ¶æ€
  const hasPackageJson = fs.existsSync(path.join(projectPath, 'package.json'));
  const hasRequirements = fs.existsSync(path.join(projectPath, 'requirements.txt')) ||
                          fs.existsSync(path.join(projectPath, 'backend/requirements.txt'));

  status.hasDependencies = hasPackageJson || hasRequirements;

  if (hasPackageJson) {
    status.dependenciesInstalled = fs.existsSync(path.join(projectPath, 'node_modules'));
  } else if (hasRequirements) {
    status.dependenciesInstalled = fs.existsSync(path.join(projectPath, 'venv')) ||
                                   fs.existsSync(path.join(projectPath, '.venv')) ||
                                   fs.existsSync(path.join(projectPath, 'backend/venv'));
  }

  return status;
}

// æ‰§è¡Œæ“ä½œ
async function executeAction(action, projectPath, project, params) {
  switch (action) {
    case 'open-directory':
      await execPromise(`open "${projectPath}"`);
      return { success: true, message: 'å·²æ‰“å¼€é¡¹ç›®ç›®å½•' };

    case 'open-vscode':
      await execPromise(`code "${projectPath}"`);
      return { success: true, message: 'å·²åœ¨ VSCode ä¸­æ‰“å¼€' };

    case 'git-status':
      const { stdout } = await execPromise('git status', { cwd: projectPath });
      return { success: true, output: stdout };

    case 'install-deps':
      if (fs.existsSync(path.join(projectPath, 'package.json'))) {
        await execPromise('npm install', { cwd: projectPath });
        return { success: true, message: 'npm ä¾èµ–å®‰è£…å®Œæˆ' };
      } else if (fs.existsSync(path.join(projectPath, 'requirements.txt'))) {
        await execPromise('pip install -r requirements.txt', { cwd: projectPath });
        return { success: true, message: 'Python ä¾èµ–å®‰è£…å®Œæˆ' };
      }
      return { success: false, message: 'æœªæ‰¾åˆ°ä¾èµ–é…ç½®æ–‡ä»¶' };

    default:
      return { success: false, message: 'æœªçŸ¥æ“ä½œ' };
  }
}

// æ³¨å†Œè¿›ç¨‹ç®¡ç†è·¯ç”±
registerProcessRoutes(app, PROJECT_ROOT, PROJECTS_CONFIG, fs);

// å¯åŠ¨æœåŠ¡å™¨
app.listen(PORT, () => {
  console.log(`ğŸš€ é¡¹ç›®ç®¡ç†ç³»ç»Ÿåç«¯è¿è¡Œåœ¨ http://localhost:${PORT}`);
  console.log(`ğŸ“ é¡¹ç›®æ ¹ç›®å½•: ${PROJECT_ROOT}`);
  console.log(`ğŸ“‹ é…ç½®æ–‡ä»¶: ${PROJECTS_CONFIG}`);
});

// ä¼˜é›…å…³é—­
process.on('SIGTERM', () => {
  console.log('æ”¶åˆ° SIGTERM ä¿¡å·ï¼Œæ­£åœ¨åœæ­¢æ‰€æœ‰è¿›ç¨‹...');
  processManager.stopAll();
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('\næ”¶åˆ° SIGINT ä¿¡å·ï¼Œæ­£åœ¨åœæ­¢æ‰€æœ‰è¿›ç¨‹...');
  processManager.stopAll();
  process.exit(0);
});
